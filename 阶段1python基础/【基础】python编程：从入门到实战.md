# 【基础】python编程：从入门到实战



## 第一章、起步

### 1.1 安装python

![image-20250514100206884](assets\image-20250514100206884-1747188130986-1.png)

- 请务必选中复选框 Add Python ... to PATH

### 1.2 终端操作

- 在终端中运行python程序：

```shell
python hello_python.py
```

- windows命令
  - **cd**： 表⽰ `change directory`，即切换⽬录
  - **dir**：表⽰ `directory`，可以显⽰当前⽬录中的所有⽂件



## 第二章、变量和简单的数据类型

### 2.1 变量

**命名**

- 变量名可以由字母、数字和下划线组成，但不能以数字开头（防止pycharm导入的问题）
- 变量名不能包含空格，但能使⽤下划线来分隔其中的单词
- 不能与python关键字和函数名重名
- 慎⽤⼩写字⺟ l 和⼤写字⺟ O，因为它们可能被⼈错看成数字 1 和 0
- 标识符是区分大小写的Andy≠andy

> 就⽬前⽽⾔，应使⽤⼩写的 Python 变量名。虽然在变量名中使⽤⼤写字⺟不会导致错误，但⼤写字⺟在变量名中有特殊的含义，这将在本书后⾯讨论。



**变量定义**

在Python中，每个变量在使用前都必须赋值(=)，变量赋值以后该变量才会被创建，可以用其他变量的计算结果来定义变量：**`money = price * weight`**



**变量的类型**

在 Python 中定义变量时不需要指定类型，Python可以根据 = 等号右侧的值，自动推导出变量中存储数据的类型

- 数字型：int；float；
- bool：真 True 非零 、假 False 0；
- 复数型 (complex)主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题
- 非数字型：字符串、列表、元组、字典



**不同类型变量之间的计算**

1. 数字型变量之间可以直接计算

2. 字符串变量之间使用 + 拼接字符串

3. 字符串变量可以和整数使用 * 重复拼接相同的字符串

4. 数字型变量和字符串之间不能进行其他计算

   

**变量的输入**

如果要获取用户在键盘上的输入信息，需要使用到 input 函数，用户输入的任何内容 Python 都认为是一个字符串，可以转换。

- 变量的格式化输出

  - % 被称为格式化操作符
    - %s：字符串
    - %d：有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方使用 0 补全
    - %f：浮点数，%.2f 表示小数点后只显示两位
    - %%：输出 %

**基本用法**

1. **语法**：`"格式化字符串" % 值` 或 `"格式化字符串" % (值1, 值2, ...)`
2. **示例**：

```python
name = "Alice"
age = 25
print("Name: %s, Age: %d" % (name, age))  # 输出：Name: Alice, Age: 25
```

| 说明符 | 类型             | 示例              | 输出      |
| :----- | :--------------- | :---------------- | :-------- |
| `%s`   | 字符串           | `"%s" % "Hello"`  | `"Hello"` |
| `%d`   | 整数             | `"%d" % 42`       | `"42"`    |
| `%f`   | 浮点数           | `"%.2f" % 3.1415` | `"3.14"`  |
| `%x`   | 十六进制（小写） | `"%x" % 255`      | `"ff"`    |
| `%X`   | 十六进制（大写） | `"%X" % 255`      | `"FF"`    |
| `%o`   | 八进制           | `"%o" % 8`        | `"10"`    |



### 2.2 字符串

- ⽤引号引起的都是字符串，其中的引号可以是单引号，也可以是双引号

	- 这种灵活性让你能够在字符串中包含引号和撇号

- 常见的方法

	- 修改单词大小写

		- title()方法

			- 以⾸字⺟⼤写的⽅式显⽰每个单词

		- upper()方法

			- 将字符串改为全⼤写

		- lower()方法

			- 将字符串改为全小写

				- 在存储数据时，lower() ⽅法很有⽤。⽤户通常不能像你期望的那样提供正确的⼤⼩写，因此需要将字符串先转换为全⼩写的再存储。以后需要显⽰这些信息时，再将其转换为最合适的⼤⼩写⽅式即可。

- 在字符串中使用变量

	- f 字符串

		- 要在字符串中插⼊变量的值，可先在左引号前加上字⺟ f，再将要插⼊的变量放在花括号内。这样，Python 在显⽰字符串时，将把每个变量都替换为其值。

			-  

- 字符串中的空白

	- 空格、制表符（\t）和换⾏符(\n)

	- 删除空白：剥除（strip）函数

		- rstrip() ⽅法

			- 删除字符串右端的空白

		- lstrip() ⽅法

			- 删除字符串左端的空白

		- strip()方法

			- 删除字符串两端的空白

- 删除前、后缀

	- 前缀：removeprefix() ⽅法

		-  

	- 后缀：removesuffix() ⽅法

- if 'a' in 'abc'

	- if 'ab' in 'abc'

### 数

- 整数

	- 可对整数（integer）执⾏加（+）减（-）乘（*）除（/）运算

		- Python 使⽤两个乘号（**）表⽰乘⽅运算

			-  

		- 可以通过使用括号来改变计算的优先级

- 浮点数

	- 需要注意的是，结果包含的⼩数位数可能是不确定的

		-  

			- 所有编程语⾔都存在这种问题，没有什么可担⼼的。Python 会尽⼒找到⼀种精确地表⽰结果的⽅式，但鉴于计算机内部表⽰数字的⽅式，这在有些情况下很难。就现在⽽⾔，暂时忽略多余的⼩数位数即可。

- 整数和浮点数

	- 将任意两个数相除，结果总是浮点数，即便这两个数都是整数且能整除

	- 在其他任何运算中，如果⼀个操作数是整数，另⼀个操作数是浮点数，结果也总是浮点数

- 数中的下划线

	- 在书写很⼤的数时，可使⽤下划线将其中的位分组，使其更清晰易读。当你打印这种使⽤下划线定义的数字时，Python 不会打印其中的下划线

		- 这是因为在存储这种数时，Python 会忽略其中的下划线。在对数字位分组时，即便不是将每三位分成⼀组，也不会影响最终的值。在 Python 看来，1000 与 1_000 没什么不同，1_000 与 10_00 也没什么不同。这种表⽰法既适⽤于整数，也适⽤于浮点数。

	-  

		-  

- 同时给多个变量赋值

	- 可在⼀⾏代码中给多个变量赋值，这有助于缩短程序并提⾼其可读性

		- 在这样做时，需要⽤逗号将变量名分开；对于要赋给变量的值，也需要做同样的处理。Python 将按顺序将每个值赋给对应的变量。只要变量数和值的个数相同，Python 就能正确地将变量和值关联起来。

- 常量

	- 常量（constant）是在程序的整个⽣命周期内都保持不变的变量

		- Python 没有内置的常量类型，但 Python 程序员会使⽤全⼤写字⺟来指出应将某个变量视为常量

			- 在代码中，要指出应将特定的变量视为常量，可将其变量名全⼤写。

### 注释

- 单行注释：#

	- 多行注释：""" """

		- """
			这是一个多行注释
			"""

			- 注释的内容会被python解释器忽略

## 第三章、列表

### 列表简介

- 列表是什么

	- 列表（list）由⼀系列按特定顺序排列的元素组成，其中的元素之间可以没有任何关系

		- 在 Python 中，⽤⽅括号（[]）表⽰列表，⽤逗号分隔其中的元素

	- 访问列表元素

		- 要访问列表元素，可指出列表的名称，再指出元素的索引，并将后者放在⽅括号内

			- 当你请求获取列表元素时，Python 只返回该元素，⽽不包括⽅括号

	- 索引从 0 ⽽不是 1 开始

		- ⼤多数编程语⾔是如此规定的，这与列表操作的底层实现有关。

			- Python 为访问最后⼀个列表元素提供了⼀种特殊语法。通过将索引指定为-1，可让 Python 返回最后⼀个列表元素

				- 这种语法很有⽤，因为你经常需要在不知道列表⻓度的情况下访问最后的元素。这种约定也适⽤于其他负数索引，例如，索引 -2 返回倒数第⼆个列表元素，索引 -3 返回倒数第三个列表元素，依此类推；

	- 使⽤列表中的各个值

		- 你可以像使⽤其他变量⼀样使⽤列表中的各个值。例如，可以使⽤ f 字符串根据列表中的值来创建消息

			-  

- 修改、添加和删除元素

	- 修改列表元素

		- 修改列表元素的语法与访问列表元素的语法类似。要修改列表元素，可指定列表名和要修改的元素的索引，再指定该元素的新值。

			-  

	- 在列表中添加元素

		- 在列表末尾添加元素

			- 在列表中添加新元素时，最简单的⽅式是将元素追加（append）到列表末尾。

				-  

		- 在列表中插⼊元素

			- 使⽤ insert() ⽅法可在列表的任意位置添加新元素。为此，需要指定新元素的索引和值：

				- 这种操作将列表中的每个既有元素都右移⼀个位置

	- 从列表中删除元素

		- 使⽤ del 语句删除元素

			- 如果知道要删除的元素在列表中的位置，可使⽤ del 语句：

		- 使⽤ pop() ⽅法删除元素

			- 有时候，你要将元素从列表中删除，并接着使⽤它的值。pop() ⽅法删除列表末尾的元素，并让你能够接着使⽤它。

			- 实际上，也可以使⽤ pop() 删除列表中任意位置的元素，只需要在括号中指定要删除的元素的索引即可。

			- 如果不确定该使⽤ del 语句还是 pop() ⽅法，下⾯是⼀个简单的判断标准：如果要从列表中删除⼀个元素，且不再以任何⽅式使⽤它，就使⽤ del 语句；如果要在删除元素后继续使⽤它，就使⽤ pop() ⽅法。

		- 删除列表中任意位置的元素

			- 有时候，你不知道要从列表中删除的值在哪个位置。如果只知道要删除的元素的值，可使⽤ remove() ⽅法。

			- remove() ⽅法只删除第⼀个指定的值。如果要删除的值，可能在列表中出现多次，就需要使⽤循环，确保将每个值都删除。

- 管理列表

	- 使⽤ sort() ⽅法对列表进⾏永久排序

		- 还可以按与字⺟顺序相反的顺序排列列表元素，只需向 sort() ⽅法传递参数 reverse=True 即可

	- 使⽤ sorted() 函数对列表进⾏临时排序

		- 在调⽤ sorted() 函数后，列表元素的排列顺序并没有变。如果要按与字⺟顺序相反的顺序显⽰列表，也可向 sorted() 函数传递参数 reverse=True

			- 注意：在并⾮所有的值都是全⼩写的时，按字⺟顺序排列列表要复杂⼀些。在确定排列顺序时，有多种解读⼤写字⺟的⽅式。

	- 使⽤ reverse() ⽅法对列表进行顺序反转

		- reverse() ⽅法会永久地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，只需对列表再次调⽤ reverse() 即可

	- 确定列表的⻓度使⽤ len() 函数可快速获悉列表的⻓度

### 操作列表

- 遍历整个列表

	- for循环

		- 这⾏代码让 Python 从列表 magicians 中取出⼀个名字，并将其与变量magician 相关联。最后，让 Python 打印前⾯赋给变量 magician 的名字。（循环结束后，最后magician变量的值为carolina）

			- 在编写 for 循环时，可以给将依次与列表中的每个值相关联的临时变量指定任意名称。然⽽，选择描述单个列表元素的有意义的名称⼤有裨益。

- 避免缩进错误

	- Python 根据缩进来判断代码⾏与程序其他部分的关系

	- 忘记缩进

		- 位于 for 语句后⾯且属于循环组成部分的代码⾏，⼀定要缩进

	- 不必要的缩进

		- 如果你不⼩⼼缩进了应在循环结束后执⾏的代码，这些代码将针对每个列表元素重复执⾏。

	- 遗漏冒号：

		- 所有需要定义代码块（缩进部分）的语句，末尾都需要冒号。记住这一点可以覆盖 99% 的情况。编写代码时，只需检查语句是否要引入缩进块，就能避免遗漏冒号的问题。

- 创建数值列表

	- 基础：range() 函数

		- Python 函数 range() 让你能够轻松地⽣成⼀系列的数。（左闭右开）

			- 在调⽤ range() 函数时，也可只指定⼀个参数，这样它将从 0 开始，例如，range(6) 返回数 0〜5（含）

	- 使⽤ range() 创建数值列表

		- 可使⽤ list() 函数将 range() 的结果直接转换为列表。

			- 在使⽤ range() 函数时，还可指定步⻓。为此，可以给这个函数指定第三个参数，Python 将根据这个步⻓来⽣成数。例如，下⾯的代码打印 1〜10 的偶数：

	- 使⽤ range() 函数⼏乎能够生成任意数值集合，。例如，如何创建⼀个列表，其中包含前 10 个整数（1〜10）的平⽅呢？

		-  

			- 为了让代码更简洁，可不使⽤临时变量 square

	- 对数值列表执⾏简单的统计计算

		- 有⼏个 Python 函数可帮助你处理数值列表。

	- 列表推导式

		- 列表推导式将 for 循环和创建新元素的代码合并成⼀⾏，并⾃动追加新元素。

			- 要使⽤这种语法，⾸先指定⼀个描述性的列表名，如 squares。然后指定⼀个左⽅括号，并定义⼀个表达式，⽤于⽣成要存储到列表中的值。在这个⽰例中，表达式为 value**2，它计算平⽅值。接下来，编写⼀个 for循环，⽤于给表达式提供值，再加上右⽅括号。

- 使用列表的一部分

	- 切片

		- 要创建切⽚，可指定要使⽤的第⼀个元素和最后⼀个元素的索引。与range() 函数⼀样，Python 在到达指定的第⼆个索引之前的元素时停⽌。

			- 这些代码打印该列表的⼀个切⽚。输出也是⼀个列表，其中包含前三名队员

		- 如果没有指定第⼀个索引，Python 将⾃动从列表开头开始：

			- 要让切⽚终⽌于列表末尾，也可使⽤类似的语法。⽆论列表多⻓，这种语法都能够让你输出从特定位置到列表末尾的所有元素。

			- 上⼀章说过，负数索引返回与列表末尾有相应距离的元素，因此可以输出列表末尾的任意切⽚。

		- 注意：可在表⽰切⽚的⽅括号内指定第三个值。这个值告诉 Python 在指定范围内每隔多少元素提取⼀个。

	- 遍历切片

		- 用for循环遍历切片

		- 切片的用途

			- 在编写游戏时，可以在玩家退出游戏时将其最终得分加⼊⼀个列表，然后将该列表按降序排列，再创建⼀个只包含前三个得分的切⽚，以获取该玩家的三个最⾼得分

			- 在处理数据时，可以使⽤切⽚来进⾏批量处理

			- 在编写 Web 应⽤程序时，可以使⽤切⽚来分⻚显⽰信息，并在每⻚上显⽰数量合适的信息

	- 复制列表：要复制列表，可以创建⼀个包含整个列表的切⽚

		- ⽅法是同时省略起始索引和终⽌索引（[:]）。这让 Python 创建⼀个起始于第⼀个元素、终⽌于最后⼀个元素的切⽚，即复制整个列表。
	在不指定任何索引的情况下，从列表my_foods 中提取⼀个切⽚，从⽽创建这个列表的副本，再将该副本赋给变量 friend_foods

		- 如果只是将 my_foods 赋给 friend_foods，就不能得到两个列表。

			- 这⾥将 my_foods 赋给 friend_foods，⽽不是将 my_foods 的副本赋给 friend_foods。这种语法实际上是让 Python 将新变量friend_foods 关联到已与 my_foods 相关联的列表，因此这两个变量指向同⼀个列表。

- 元组

	- Python将不能修改的值称为不可变的，⽽不可变的列表称为元组

	- 定义元组

		- 元组看起来很像列表，但使⽤圆括号⽽不是⽅括号来标识。

			- 定义元组后，就可使⽤索引来访问其元素，就像访问列表元素⼀样。

		- 注意：严格地说，元组是由逗号标识的，圆括号只是让元组看起来更整洁、更清晰。如果你要定义只包含⼀个元素的元组，必须在这个元素后⾯加上逗号

	- 遍历元组中的所有值

		- 和列表一样，用for循环

	- 修改元组变量

		- 虽然不能修改元组的元素，但可以给表⽰元组的变量赋值。

			-  

- 格式设置指南

	- PEP 8 是最古⽼的 PEP 之⼀，向 Python 程序员提供了代码格式设置指南。

	- 缩进

		- PEP 8 建议每级缩进都使⽤ 4 个空格

			- 用空格而不是制表符来缩进

				- 在程序中混合使⽤制表符和空格可能导致极难排除的问题。

				- 每款⽂本编辑器都提供了⼀种设置，可将你输⼊的制表符转换为指定数量的空格。你可以在编写代码时使⽤ Tab 键，但是⼀定要对编辑器进⾏设置，使其在⽂档中插⼊空格⽽不是制表符。

	- ⾏⻓

		- 很多 Python 程序员建议每⾏不超过 80 个字符

		- PEP 8 还建议注释的⾏⻓不超过 72 个字符，因为有些⼯具为⼤型项⽬⾃动⽣成⽂档时，会在每⾏注释开头添加格式化字符。

			- 在⼤多数编辑器中，可以设置⼀个视觉标志（通常是⼀条竖线），让你知道不能越过的界线在什么地⽅。

	- 空⾏

		- 要将程序的不同部分分开，可使⽤空⾏，但是不要滥⽤

			- 空⾏不会影响代码的运⾏，但会影响代码的可读性。Python 解释器根据⽔平缩进情况来解读代码，但不关⼼垂直间距。

## 第四章、if语句

### 条件测试

- 每条 if 语句的核⼼都是⼀个值为 True 或 False 的表达式，这种表达式称为条件测试。
Python 根据条件测试的值是 True 还是 False 来决定是否执⾏ if 语句中的代码。如果条件测试的值为 True，Python 就执⾏紧跟在if 语句后⾯的代码；如果为 False，Python 就忽略这些代码。

- 检查是否相等

	- =：赋值；==：判断是否相等

		- 在 Python 中检查是否相等时是区分⼤⼩写的

			- 如果⼤⼩写⽆关紧要，你只想检查变量的值，可先将变量的值转换为全⼩写的，再进⾏⽐较。
lower() ⽅法不会修改存储在变量 car 中的值，因此进⾏这样的⽐较不会影响原来的变量

- 检查是否不等

	- !=：判断两个值是否不等

- 数值⽐较

	- <：⼩于；<=：⼩于等于；>：⼤于；>=：⼤于等于

- 检查多个条件

	- and

		- 全真为真，一假为假

	- or

		- 一真为真，全假为假

- 检查特定的值是否在列表中

	- in

		-  

	- not in

- 布尔表达式

	- 随着对编程的了解越来越深⼊，你将遇到术语布尔表达式，它不过是条件测试的别名罢了。与条件表达式⼀样，布尔表达式的结果要么为 True，要么为 False。

		-  

### if语句

- 简单的 if 语句

	- 最简单的 if 语句只有⼀个条件测试和⼀个操作：

- if-else 语句

	- 你经常需要在条件测试通过时执⾏⼀个操作，在没有通过时执⾏另⼀个操作。在这种情况下，可使⽤ Python 提供的 if-else 语句。

		- if-else 结构⾮常适合⽤于让 Python 执⾏两种操作之⼀的情形。在这样简单的 if-else 结构中，总会执⾏两个操作中的⼀个。

- if-elif-else 语句

	- 你经常需要检查两个以上的情形，此时可使⽤ Python 提供的 if-elifelse 语句。

	- 省略 else 代码块

		- Python 并不要求 if-elif 结构后⾯必须有 else 代码块（和if一样）。在⼀些情况下，else 代码块很有⽤；⽽在其他情况下，使⽤⼀条 elif 语句来处理特定的情形更清晰

			- else 是⼀条包罗万象的语句，只要不满⾜任何 if 或 elif 中的条件测试，其中的代码就会执⾏。这可能引⼊⽆效甚⾄恶意的数据。如果知道最终要测试的条件，应考虑使⽤⼀个 elif 代码块来代替 else 代码块。这样就可以肯定，仅当满⾜相应的条件时，代码才会执⾏

- 测试多个条件

	- 然有时候必须检查你关⼼的所有条件。在这种情况下，应使⽤⼀系列不包含 elif 和 else 代码块的简单 if 语句。在可能有多个条件为True，且需要在每个条件为 True 时都采取相应措施时，适合使⽤这种⽅法

		- 总之，如果只想运⾏⼀个代码块，就使⽤ if-elif-else 语句；如果要运⾏多个代码块，就使⽤⼀系列独⽴的 if 语句

### 使⽤ if 语句处理列表

- 结合使⽤ if 语句和列表，可完成⼀些有趣的任务：对列表中特定的值做特殊处理

- 检查特殊元素

	-  

- 确定列表⾮空

	- 在 if 语句中将列表名⽤作条件表达式时，Python将在列表⾄少包含⼀个元素时返回 True，在列表为空时返回 False

		- 对于数值 0、空值 None、单引号空字符串 ''、双引号空字符串 ""、空列表 []、空元组 ()、空字典 {}，Python 都会返回 False。

### 设置 if 语句的格式

- PEP 8 提供的唯⼀建议是：在诸如 ==、>= 和 <= 等⽐较运算符两边各添加⼀个空格。

## 第五章、字典

### 使用字典

- 在 Python 中，字典（dictionary）是⼀系列键值对。

	- 每个键都与⼀个值关联，可以使⽤键来访问与之关联的值。与键相关联的值可以是数、字符串、列表乃⾄字典。事实上，可将任意 Python 对象⽤作字典中的值。

- 在 Python 中，字典⽤放在花括号（{}）中的⼀系列键值对表⽰

	- 键值对包含两个相互关联的值。当你指定键时，Python 将返回与之关联的值。键和值之间⽤冒号分隔，⽽键值对之间⽤逗号分隔。

- 访问字典中的值

	- 要获取与键关联的值，可指定字典名并把键放在后⾯的⽅括号内

		-  

- 添加键值对

	- 字典是⼀种动态结构，可随时在其中添加键值对。要添加键值对，可依次指定字典名、⽤⽅括号括起来的键和与该键关联的值

		- 字典会保留定义时的元素排列顺序。如果将字典打印出来或遍历其元素，将发现元素的排列顺序与其添加顺序相同

- 修改字典中的值 

	- 要修改字典中的值，可依次指定字典名、⽤⽅括号括起来的键和与该键关联的新值。

		-  

- 删除键值对

	- 对于字典中不再需要的信息，可使⽤ del 语句将相应的键值对彻底删除。在使⽤ del 语句时，必须指定字典名和要删除的键

		- del 语句让 Python 将键 'points' 从字典 alien_0 中删除，同时删除与这个键关联的值。
注意：删除的键值对永远消失了。

- 由类似的对象组成的字典

	- 字典也可以使⽤字典来存储众多对象的同⼀种信息

		- ⼀种不错的做法是，在最后⼀个键值对后⾯也加上逗号，为以后添加键值对做好准备。

- 使⽤ get() 方法来访问值

	- 使⽤放在⽅括号内的键从字典中获取感兴趣的值，可能会引发问题：如果指定的键不存在，就将出错。

		- 就字典⽽⾔，为避免出现这样的错误，可使⽤ get() ⽅法在指定的键不存在时返回⼀个默认值。get() ⽅法的第⼀个参数⽤于指定键，是必不可少的；第⼆个参数为当指定的键不存在时要返回的值，是可选的

			- 注意：在调⽤ get() 时，如果没有指定第⼆个参数且指定的键不存在，Python 将返回值 None，这个特殊的值表⽰没有相应的值。这并⾮错误，None 只是⼀个表⽰所需值不存在的特殊值

### 遍历字典

- 遍历所有的键值对

	- 可使⽤ for 循环来遍历这个字典

		- 要编写遍历字典的 for 循环，可声明两个变量，分别⽤于存储键值对中的键和值。

		- for 语句的第⼆部分包含字典名和⽅法 items()，这个⽅法返回⼀个键值对列表。接下来，for 循环依次将每个键值对赋给指定的两个变量。

- 遍历字典中的所有键

	- 在不需要使⽤字典中的值时，keys() ⽅法很有⽤

		- 在遍历字典时，会默认遍历所有的键。因此，如果将上述代码中的

			- 替换为以下代码，输出将不变

		- 在这种循环中，可使⽤当前的键来访问与之关联的值。

		- 还可以使⽤ keys() 确定某个⼈是否接受了调查。

			- keys() ⽅法并⾮只能⽤于遍历：实际上，它会返回⼀个列表，其中包含字典中的所有键。因此 if 语句只核实 'erin' 是否在这个列表中。

	- 按特定的顺序遍历字典中的所有键

		- 遍历字典时将按插⼊元素的顺序返回其中的元素，但是在⼀些情况下，你可能要按与此不同的顺序遍历字典。

			- 要以特定的顺序返回元素，⼀种办法是在 for 循环中对返回的键进⾏排序。为此，可使⽤sorted() 函数来获得按特定顺序排列的键列表的副本

- 遍历字典中的所有值

	- 如果你感兴趣的是字典包含的值，可使⽤ values() ⽅法。它会返回⼀个值列表，不包含任何键。

		- 这种做法提取字典中所有的值，⽽没有考虑值是否有重复。为剔除重复项，可使⽤集合（set）。集合中的每个元素都必须
			是独⼀⽆⼆的。

			- 通过将包含重复元素的列表传⼊ set()，可让 Python 找出列表中独⼀⽆⼆的元素，并使⽤这些元素来创建⼀个集合。

			- 注意：可以使⽤⼀对花括号直接创建集合，并在其中⽤逗号分隔元素：

### 嵌套

- 有时候，需要将多个字典存储在列表中或将列表作为值存储在字典中，这称为嵌套。可以在列表中嵌套字典，在字典中嵌套列表，甚⾄在字典中嵌套字典。

- 字典列表

	-  

- 在字典中存储列表

	- 在下⾯的⽰例中，存储了⽐萨两个⽅⾯的信息：外⽪类型和配料列表。配料列表是⼀个与键 'toppings' 关联的值。要访问该列表，我们使⽤字典名和键 'toppings'，就像访问字典中的其他值⼀样。这将返回⼀个配料列表，⽽不是单个值。

		- 当函数调⽤print() 中的字符串很⻓，需要分成多⾏书写时，可以在合适的位置分⾏，在每⾏末尾都加上引号，并且对于除第⼀⾏外的其他各⾏，都在⾏⾸加上引号并缩进。这样，Python 将⾃动合并括号内的所有字符串。

		- 每当需要在字典中将⼀个键关联到多个值时，都可以在字典中嵌套⼀个列表。

		- 需要遍历列表中的数据，需要再用一个for循环

			- 注意：列表和字典的嵌套层级不应太多。如果嵌套层级⽐前⾯的⽰例多得多，很可能有更简单的解决⽅案。

- 在字典中存储字典

	- 如果有⼀⽹站有多个⽤户，每个⽤户都有独特的⽤户名，可在字典中将⽤户名作为键，然后将每个⽤户的信息存储在⼀个字典中，并将该字典作为与⽤户名关联的值。

		-  

## 第六章、用户输入和while循环

### input() 函数的⼯作原理

- input() 函数让程序暂停运⾏，等待⽤户输⼊⼀些⽂本。获取⽤户输⼊后，Python 将其赋给⼀个变量，以便使⽤。

	- input() 函数接受⼀个参数，即要向⽤户显⽰的提⽰（prompt），让⽤户知道该输⼊什么样的信息。

- 编写清晰的提⽰

	- 通过在提⽰末尾（这⾥是冒号后⾯）添加⼀个空格，可将提⽰与⽤户输⼊分开，让⽤户清楚地知道其输⼊始于何处，如下所⽰

		- 有时候，提⽰可能超过⼀⾏

			- 在这种情况下，可先将提⽰赋给⼀个变量，再将这个变量传递给input() 函数。这样，即便提⽰超过⼀⾏，input() 语句也会⾮常清晰。

- 使⽤ int() 来获取数值输⼊

	- 在使⽤ input() 函数时，Python 会将⽤户输⼊解读为字符串。当试图将该输⼊⽤于数值⽐较时，Python 会报错，因为它⽆法将字符串和整数进⾏⽐较

		- 为了解决这个问题，可使⽤函数 int() 将输⼊的字符串转换为数值，确保能够成功地执⾏⽐较操作

- 求模运算符

	- 在处理数值信息时，求模运算符（%）是个很有⽤的⼯具，它将两个数相除并返回余数

### while 循环简介

- for 循环⽤于针对集合中的每个元素执⾏⼀个代码块，⽽ while 循环则不断地运⾏，直到指定的条件不再满⾜为⽌

- 使⽤ while 循环

	- 可以使⽤ while 循环来数数

- 让⽤户选择何时退出

	- 可以使⽤ while 循环让程序在⽤户愿意时不断地运⾏，如下⾯的程序parrot.py 所⽰。我们在其中定义了⼀个退出值，只要⽤户输⼊的不是这个值，程序就将⼀直运⾏

		- 我们将变量 message 的初始值设置为空字符串 让Python 在⾸次执⾏ while 代码⾏时有可供检查的东⻄。如果没有可供⽐较的东⻄，Python 将⽆法继续运⾏程序。为解决这个问题，必须给变量 message 指定初始值。

- 使⽤标志

	- 当导致程序结束的事件有很多时，如果在⼀条 while 语句中检查所有这些条件，将既复杂⼜困难

		- 在要求满⾜很多条件才继续运⾏的程序中，可定义⼀个变量，⽤于判断整个程序是否处于活动状态。这个变量称为标志（flag），充当程序的交通信号灯。可以让程序在标志为 True 时继续运⾏，并在任何事件导致标志的值为 False 时让程序停⽌运⾏。这样，在 while 语句中就只需检查⼀个条件：标志的当前值是否为 True。然后将所有测试（是否发⽣了应将标志设置为 False 的事件）都放在其他地⽅，从⽽让程序更整洁。

			- 这样，添加测试（如 elif 语句）以检查是否发⽣了其他导致 active变为 False 的事件，就会很容易。在复杂的程序（⽐如有很多事件会导致程序停⽌运⾏的游戏）中，标志很有⽤：在任意⼀个事件导致活动标志变成 False 时，主游戏循环将退出。

- 使⽤ break 退出循环

	- 如果不管条件测试的结果如何，想⽴即退出 while 循环，不再运⾏循环中余下的代码，可使⽤ break 语句。

		- 注意：在所有 Python 循环中都可使⽤ break 语句。例如，可使⽤break 语句来退出遍历列表或字典的 for 循环

- 在循环中使⽤ continue

	- 要返回循环开头，并根据条件测试的结果决定是否继续执⾏循环，可使⽤continue 语句，它不像 break 语句那样不再执⾏余下的代码并退出整个循环。例如，来看⼀个从 1 数到 10，只打印其中奇数的循环：

- 避免⽆限循环

### 使⽤ while 循环处理列表和字典

- for 循环是⼀种遍历列表的有效⽅式，但不应该在 for 循环中修改列表，否则将导致 Python 难以跟踪其中的元素。要在遍历列表的同时修改它，可使⽤ while 循环。通过将 while 循环与列表和字典结合起来使⽤，可收集、存储并组织⼤量的输⼊，供以后查看和使⽤

- 在列表之间移动元素

	- 假设有⼀个列表包含新注册但还未验证的⽹站⽤户。验证这些⽤户后，如何将他们移到已验证⽤户列表中呢？

- 删除为特定值的所有列表元素

	- 我们使⽤ remove() 函数来删除列表中的特定值。这之所以可⾏，是因为要删除的值在列表中只出现了⼀次。如果要删除列表中所有为特定值的元素，该怎么办呢

- 使⽤⽤户输⼊填充字典

	- 可以使⽤ while 循环提⽰⽤户输⼊任意多的信息

## 第七章、函数

### 定义函数

- 第⼀⾏代码使⽤关键字 def 来告诉Python，你要定义⼀个函数。这是函数定义，向 Python 指出了函数名，还可以在括号内指出函数为完成任务需要什么样的信息。在这⾥，函数名为greet_user()，它不需要任何信息就能完成⼯作，因此括号内是空的（即便如此，括号也必不可少）。最后，定义以冒号结尾。

	- 紧跟在 def greet_user(): 后⾯的所有缩进⾏构成了函数体。第⼆⾏的⽂本是称为⽂档字符串（docstring）的注释，描述了函数是做什么的。Python 在为程序中的函数⽣成⽂档时，会查找紧跟在函数定义后的字符串。这些字符串通常前后分别⽤三个双引号引起，能够包含多⾏。

		- 要使⽤这个函数，必须调⽤它。函数调⽤让Python 执⾏函数中的代码。要调⽤函数，可依次指定函数名以及⽤括号括起的必要信息。

- 向函数传递信息

	- 为此，可在函数定义 def greet_user() 的括号内添加username。这样，可让函数接受你给username 指定的任何值。现在，这个函数要求你在调⽤它时给 username 指定⼀个值，因此在调⽤greet_user() 时，可将⼀个名字传递给它，如下所⽰：

- 实参和形参

	- 在 greet_user() 函数的定义中，变量 username 是⼀个形参（parameter），即函数完成⼯作所需的信息。在代码greet_user('jesse') 中，值 'jesse' 是⼀个实参（argument），即在调⽤函数时传递给函数的信息。

### 传递实参

- 函数定义中可能包含多个形参，因此函数调⽤中也可能包含多个实参。向函数传递实参的⽅式很多：既可以使⽤位置实参，这要求实参的顺序与形参的顺序相同；也可以使⽤关键字实参，其中每个实参都由变量名和值组成；还可以使⽤列表和字典。

- 位置实参

	- 在调⽤函数时，Python 必须将函数调⽤中的每个实参关联到函数定义中的⼀个形参。最简单的⽅式是基于实参的顺序进⾏关联。以这种⽅式关联的实参称为位置实参。

	-  

		- 在调⽤describe_pet() 时，需要按顺序提供⼀个动物类型和⼀个名字。

		- 在函数中，可根据需要使⽤任意数量的位置实参，Python 将按顺序将函数调⽤中的实参关联到函数定义中相应的形参。

- 关键字实参

	- 关键字实参是传递给函数的名值对。这样会直接在实参中将名称和值关联起来，因此向函数传递实参时就不会混淆了。关键字实参不仅让你⽆须考虑函数调⽤中的实参顺序，⽽且清楚地指出了函数调⽤中各个值的⽤途。

	-  

		- describe_pet() 函数还和之前⼀样，但这次调⽤这个函数时，向 Python明确地指出了各个实参对应的形参。当看到这个函数调⽤时，Python 知道应该将实参 'hamster' 和 'harry' 分别赋给形参 animal_type 和pet_name。

		- 关键字实参的顺序⽆关紧要，因为 Python 知道各个值该被赋给哪个形参。下⾯两个函数调⽤是等效的：

			- 注意：在使⽤关键字实参时，务必准确地指定函数定义中的形参名

- 默认值

	- 在编写函数时，可以给每个形参指定默认值。如果在调⽤函数中给形参提供了实参，Python 将使⽤指定的实参值；否则，将使⽤形参的默认值。因此，给形参指定默认值后，可在函数调⽤中省略相应的实参。

	- 如果你发现在调⽤ describe_pet() 时，描述的⼤多是⼩狗，就可将形参 animal_type 的默认值设置为 'dog'。这样，当调⽤describe_pet() 来描述⼩狗时，就可以不提供该信息

		- 在调⽤这个函数时，如果没有给animal_type 指定值，Python 将⾃动把这个形参设置为 'dog'

		- 请注意，在这个函数的定义中，修改了形参的排列顺序。由于给animal_type 指定了默认值，⽆须通过实参来指定动物类型，因此函数调⽤只包含⼀个实参——宠物的名字。然⽽，Python 依然将这个实参视为位置实参，如果函数调⽤只包含宠物的名字，这个实参将被关联到函数定义中的第⼀个形参。这就是需要将 pet_name 放在形参列表开头的原因。

		- 如果要描述的动物不是⼩狗，可使⽤类似于下⾯的函数调⽤：

			- 由于显式地给 animal_type 提供了实参，Python 将忽略这个形参的默认值。

	- 注意：当使⽤默认值时，必须在形参列表中先列出没有默认值的形参，再列出有默认值的形参。这让 Python 依然能够正确地解读位置实参。

- 等效的函数调⽤

	- 鉴于可混合使⽤位置实参、关键字实参和默认值，通常有多种等效的函数调⽤⽅式。

		- 基于这种定义，在任何情况下都必须给 pet_name 提供实参。在指定该实参时，既可以使⽤位置实参，也可以使⽤关键字实参。如果要描述的动物不是⼩狗，还必须在函数调⽤中给 animal_type 提供实参。同样，在指定该实参时，既可以使⽤位置实参，也可以使⽤关键字实参。

	- 下⾯对这个函数的所有调⽤都可⾏

- 避免实参错误

	- 当你提供的实参多于或少于函数完成⼯作所需的实参数量时，将出现实参不匹配错误。

### 返回值

- 在函数中，可以使⽤ return 语句将值返回到调⽤函数的那⾏代码。返回值让你能够将程序的⼤部分繁重⼯作移到函数中完成，从⽽简化主程序。

- 返回简单的值

	- 在调⽤可以返回值的函数时，需要提供⼀个变量，以便将返回的值赋给它。

- 让实参变成可选的

	- 有时候，需要让实参变成可选的，以便使⽤函数的⼈只在必要时才提供额外的信息。可以使⽤默认值来让实参变成可选的。

	- 假设要扩展 get_formatted_name() 函数，使其除了名和姓之外还可以处理中间名。

		- 然⽽，并⾮所有⼈都有中间名。如果调⽤这个函数时只提供了名和姓，它将不能正确地运⾏。为让中间名变成可选的，可给形参 middle_name 指定默认值（空字符串），并将其移到形参列表的末尾，在⽤户不提供中间名时不使⽤这个形参。

		- Python 将⾮空字符串解读为 True

		- 在调⽤这个函数时，如果只想指定名和姓，调⽤起来将⾮常简单。如果还要指定中间名，就必须确保它是最后⼀个实参，这样 Python 才能正确地将位置实参关联到形参

- 返回字典

	- 函数可返回任何类型的值，包括列表和字典等较为复杂的数据结构。

		- 你可以轻松地扩展这个函数，使其接受可选值，如中间名、年龄、职业或其他任何要存储的信息

			- 在函数定义中，新增了⼀个可选形参 age，其默认值被设置为特殊值 None（表⽰变量没有值）。可将 None 视为占位值。在条件测试中，None 相当于 False。

### 传递列表

- 你经常会发现，向函数传递列表很有⽤，可能是名字列表、数值列表或更复杂的对象列表（如字典）。将列表传递给函数后，函数就能直接访问其内容

- 在函数中修改列表

	- 将列表传递给函数后，函数就可以对其进⾏修改了。在函数中对这个列表所做的任何修改都是永久的，这让你能够⾼效地处理⼤量数据。

	-  

		- 可以重新组织这些代码，编写两个函数，让每个都做⼀件具体的⼯作。⼤部分代码与原来相同，只是结构更为合理。第⼀个函数负责处理打印设计的⼯作，第⼆个概述打印了哪些设计：

		-  

			- 虽然这个程序的输出与未使⽤函数的版本相同，但是代码更有条理。完成⼤部分⼯作的代码被移到了两个函数中，让主程序很容易理解。只要看看主程序，你就能轻松地知道这个程序的功能

			- 相⽐于没有使⽤函数的版本，这个程序更容易扩展和维护。如果以后需要打印其他设计，只需再次调⽤ print_models() 即可。如果发现需要对模拟打印的代码进⾏修改，只需修改这些代码⼀次，就将影响所有调⽤该函数的地⽅。与必须分别修改程序的多个地⽅相⽐，这种修改的效率更⾼。

			- 这个程序还演⽰了⼀种理念：每个函数都应只负责⼀项具体⼯作。⽤第⼀个函数打印每个设计，⽤第⼆个函数显⽰打印好的模型，优于使⽤⼀个函数完成这两项⼯作。

- 禁⽌函数修改列表

	- 为了解决这个问题，可向函数传递列表的副本⽽不是原始列表。这样，函数所做的任何修改都只影响副本，⽽丝毫不影响原始列表。

		- 切⽚表⽰法 [:] 创建列表的副本

		- 虽然向函数传递列表的副本可保留原始列表的内容，但除⾮有充分的理由，否则还是应该将原始列表传递给函数。这是因为，让函数使⽤现成的列表可避免花时间和内存创建副本，从⽽提⾼效率，在处理⼤型列表时尤其如此。

### 传递任意数量的实参

- 有时候，你预先不知道函数需要接受多少个实参，例如⼀个制作⽐萨的函数，它需要接受很多配料，但⽆法预先确定顾客要点多少种配料。下⾯的函数只有⼀个形参 *toppings，不管调⽤语句提供了多少实参，这个形参都会将其收⼊囊中：

	- 形参名 *toppings 中的星号让 Python 创建⼀个名为 toppings 的元组，该元组包含函数收到的所有值。

- 结合使⽤位置实参和任意数量的实参

	- 如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python 先匹配位置实参和关键字实参，再将余下的实参都收集到最后⼀个形参中。

		- 基于上述函数定义，Python 将收到的第⼀个值赋给形参 size，将其他所有的值都存储在元组 toppings 中。在函数调⽤中，⾸先指定表⽰⽐萨尺⼨的实参，再根据需要指定任意数量的配料。

		- 注意：你经常会看到通⽤形参名 *args，它也这样收集任意数量的位置实参。

- 使⽤任意数量的关键字实参

	- 有时候，你需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键值对——调⽤语句提供了多少就接受多少。

	- 形参 **user_info 中的两个星号让 Python 创建⼀个名为 user_info 的字典，该字典包含函数收到的其他所有名值对。

	- 在 build_profile() 的函数体内，将名和姓加⼊字典 user_info（⻅❶），因为总是会从⽤户那⾥收到这两项信息，⽽这两项信息还没被放在字典中。接下来，将字典 user_info 返回函数调⽤⾏。

	- 注意：你经常会看到形参名 **kwargs，它⽤于收集任意数量的关键字实参。

### 将函数存储在模块中

- 导⼊整个模块

	- 使⽤函数的优点之⼀是可将代码块与主程序分离。通过给函数指定描述性名称，能让程序容易理解得多。你还可以更进⼀步，将函数存储在称为模块的独⽴⽂件中，再将模块导⼊（import）主程序。import 语句可让你在当前运⾏的程序⽂件中使⽤模块中的代码。

		- 通过将函数存储在独⽴的⽂件中，可隐藏程序代码的细节，将重点放在程序的⾼层逻辑上。这还能让你在众多不同的程序中复⽤函数。

	- 要让函数是可导⼊的，得先创建模块。模块是扩展名为 .py 的⽂件，包含要导⼊程序的代码。

	- 当 Python 读取这个⽂件时，代码⾏ import pizza 会让 Python 打开⽂件pizza.py，并将其中的所有函数都复制到这个程序中。你看不到复制代码的过程，因为 Python 会在程序即将运⾏时在幕后复制这些代码。你只需要知道，在 making_pizzas.py 中，可使⽤ pizza.py 中定义的所有函数。

		- 要调⽤被导⼊模块中的函数，可指定被导⼊模块的名称 pizza 和函数名make_pizza()，并⽤句点隔开（⻅❶）。

	- 这就是⼀种导⼊⽅法：只需编写⼀条 import 语句并在其中指定模块名，就可在程序中使⽤该模块中的所有函数。如果使⽤这种 import 语句导⼊了名为 module_name.py 的整个模块，就可使⽤下⾯的语法来使⽤其中的任意⼀个函数：

- 导⼊特定的函数

	- 还可以只导⼊模块中的特定函数，语法如下：

		- ⽤逗号分隔函数名，可根据需要从模块中导⼊任意数量的函数：

	- 如果使⽤这种语法，在调⽤函数时则⽆须使⽤句点。由于在 import 语句中显式地导⼊了 make_pizza() 函数，因此在调⽤时只需指定其名称即可。

- 使⽤ as 给函数指定别名

	- 如果要导⼊的函数的名称太⻓或者可能与程序中既有的名称冲突，可指定简短⽽独⼀⽆⼆的别名（alias）：函数的另⼀个名称，类似于外号。要给函数指定这种特殊的外号，需要在导⼊时这样做

	- 下⾯给 make_pizza() 函数指定了别名 mp()。这是在 import 语句中使⽤ make_pizza as mp 实现的，关键字 as 将函数重命名为指定的别名：

- 使⽤ as 给模块指定别名

	- 还可以给模块指定别名。通过给模块指定简短的别名（如给 pizza 模块指定别名 p），你能够更轻松地调⽤模块中的函数。

- 导⼊模块中的所有函数

	- 使⽤星号（*）运算符可让 Python 导⼊模块中的所有函数

	- import 语句中的星号让 Python 将模块 pizza 中的每个函数都复制到这个程序⽂件中。由于导⼊了每个函数，可通过名称来调⽤每个函数，⽆须使⽤点号（dot notation）。

		- 然⽽，在使⽤并⾮⾃⼰编写的⼤型模块时，最好不要使⽤这种导⼊⽅法，因为如果模块中有函数的名称与当前项⽬中既有的名称相同，可能导致意想不到的结果：Python 可能会因为遇到多个名称相同的函数或变量⽽覆盖函数，⽽不是分别导⼊所有的函数。

		- 最佳的做法是，要么只导⼊需要使⽤的函数，要么导⼊整个模块并使⽤点号。这都能让代码更清晰，更容易阅读和理解

### 函数编写指南

- 应给函数指定描述性名称，且只使⽤⼩写字⺟和下划线。

- 每个函数都应包含简要阐述其功能的注释。该注释应紧跟在函数定义后⾯，并采⽤⽂档字符串的格式。

- 在给形参指定默认值时，等号两边不要有空格

	- 函数调⽤中的关键字实参也应遵循这种约定

- PEP 8 建议代码⾏的⻓度不要超过 79 个字符。如果形参很多，导致函数定义的⻓度超过了 79 个字符，可在函数定义中输⼊左括号后按回⻋键，并在下⼀⾏连按两次制表符键，从⽽将形参列表和只缩进⼀层的函数体区分开来。

- 如果程序或模块包含多个函数，可使⽤两个空⾏将相邻的函数分开

- 所有的 import 语句都应放在⽂件开头。唯⼀的例外是，你要在⽂件开头使⽤注释来描述整个程序。

## 第八章、类

### 创建和使⽤类

- 创建 Dog 类

	- 由于⼤多数⼩狗具备上述两项信息（名字和年龄）和两种⾏为（坐下和打滚），我们的 Dog 类将包含它们。这个类让 Python 知道如何创建表⽰⼩狗的对象。编写这个类后，我们将使⽤它来创建表⽰特定⼩狗的实例。

		- 根据约定，在 Python 中，⾸字⺟⼤写的名称指的是类。因为这是我们创建的全新的类，所以定义时不加括号。然后是⼀个⽂档字符串，对这个类的功能做了描述。

		- __init__() ⽅法：类中的函数称为⽅法。__init__()（⻅❷）是⼀个特殊⽅法，每当你根据 Dog 类创建新实例时，Python 都会⾃动运⾏它。在这个⽅法的名称中，开头和末尾各有两个下划线，这是⼀种约定，旨在避免 Python 默认⽅法与普通⽅法发⽣名称冲突。务必确保__init__() 的两边都有两个下划线，否则当你使⽤类来创建实例时，将不会⾃动调⽤这个⽅法，进⽽引发难以发现的错误。

			- 在这个⽅法的定义中，形参 self 必不可少，⽽且必须位于其他形参的前⾯。为何必须在⽅法定义中包含形参 self 呢？因为当 Python 调⽤这个⽅法来创建 Dog 实例时，将⾃动传⼊实参 self。每个与实例相关联的⽅法调⽤都会⾃动传递实参 self，该实参是⼀个指向实例本⾝的引⽤，让实例能够访问类中的属性和⽅法。

			- 我们将通过实参向 Dog() 传递名字和年龄；self 则会⾃动传递，因此不需要我们来传递。

		- 在 __init__() ⽅法内定义的两个变量都有前缀 self（⻅❸）。以self为前缀的变量可供类中的所有⽅法使⽤，可以通过类的任意实例来访问。

			- 像这样可通过实例访问的变量称为属性

		- Dog 类还定义了另外两个⽅法：sit() 和roll_over()（⻅❹）。由于这些⽅法执⾏时不需要额外的信息，因此只有⼀个形参 self。

- 根据类创建实例

	- 可以将类视为有关如何创建实例的说明。

		- 。我们让 Python 创建⼀条名字为'Willie'、年龄为 6 的⼩狗（⻅❶）。在处理这⾏代码时，Python 调⽤Dog 类的 __init__() ⽅法，并传⼊实参 'Willie' 和 6。接下来，Python 返回⼀个表⽰这条⼩狗的实例，⽽我们将这个实例赋给变量 my_dog

			- 在这⾥，命名约定很有⽤：通常可以认为⾸字⺟⼤写的名称（如 Dog）指的是类，⽽全⼩写的名称（如 my_dog）指的是根据类创建的实例。

	- 访问属性

		- 要访问实例的属性，可使⽤点号

			- 在 Dog 类中引⽤这个属性时，使⽤的是self.name

	- 调⽤⽅法

		- 根据 Dog 类创建实例后，就能使⽤点号来调⽤ Dog 类中定义的任何⽅法了。

			- 要调⽤⽅法，需指定实例名（这⾥是 my_dog）和想调⽤的⽅法，并⽤句点分隔

	- 创建多个实例

		-  

			- 每条⼩狗都是⼀个独⽴的实例，有⾃⼰的⼀组属性，能够执⾏相同的操作

			- 即使给第⼆条⼩狗指定同样的名字和年龄，Python 也会根据 Dog 类创建另⼀个实例

### 使⽤类和实例

- 可以使⽤类来模拟现实世界中的很多情景。

- Car 类

	-  

		- 为了在get_descriptive_name()⽅法中访问属性的值，使⽤了self.make、self.model 和 self.year

- 给属性指定默认值

	- 有些属性⽆须通过形参来定义，可以在 __init__() ⽅法中为其指定默认值。

- 修改属性的值

	- 直接修改属性的值

		- 要修改属性的值，最简单的⽅式是通过实例直接访问它

	- 通过⽅法修改属性的值

		- 有⼀个替你更新属性的⽅法⼤有裨益。这样就⽆须直接访问属性了，⽽是可将值传递给⽅法，由它在内部进⾏更新

	- 通过⽅法让属性的值递增

		- 有时候需要将属性值递增特定的量，⽽不是将其设置为全新的值。

### 继承

- 在编写类时，并⾮总是要从头开始。如果要编写的类是⼀个既有的类的特殊版本，可使⽤继承（inheritance）。

	- 当⼀个类继承另⼀个类时，将⾃动获得后者的所有属性和⽅法。原有的类称为⽗类（parent class），⽽新类称为⼦类（child class）。⼦类不仅继承了⽗类的所有属性和⽅法，还可定义⾃⼰的属性和⽅法。

- ⼦类的 __init__() ⽅法

	- 在既有的类的基础上编写新类，通常要调⽤⽗类的 __init__() ⽅法。这将初始化在⽗类的 __init__() ⽅法中定义的所有属性，从⽽让⼦类也可以使⽤这些属性。

		-  

			-  

		- ⾸先是 Car 类的代码（⻅❶）。在创建⼦类时，⽗类必须包含在当前⽂件中，且位于⼦类前⾯。接下来，定义⼦类 ElectricCar（⻅❷）。在定义⼦类时，必须在括号内指定⽗类的名称。__init__() ⽅法接受创建 Car实例所需的信息（⻅❸）

			- super() 是⼀个特殊的函数，让你能够调⽤⽗类的⽅法（⻅❹）。⽗类也称为超类（superclass），函数名super 由此得名。

- 给⼦类定义属性和⽅法

	- 让⼀个类继承另⼀个类后，就可以添加区分⼦类和⽗类所需的新属性和新⽅法了

	- 下⾯添加⼀个电动汽⻋特有的属性（电池），以及⼀个描述该属性的⽅法。

		- 在❶处，添加新属性self.battery_size，并设置其初始值（40）。根据 ElectricCar 类创建的所有实例都将包含这个属性，但所有的 Car 实例都不包含它。

- 重写⽗类中的⽅法

	- 在使⽤⼦类模拟的实物的⾏为时，如果⽗类中的⼀些⽅法不能满⾜⼦类的需求，就可以⽤下⾯的办法重写：在⼦类中定义⼀个与要重写的⽗类⽅法同名的⽅法。这样，Python 将忽略这个⽗类⽅法，只关注你在⼦类中定义的相应⽅法。

		- 在使⽤继承时，可让⼦类保留从⽗类那⾥继承的“精华”，重写不需要的“糟粕”。

- 将实例⽤作属性

	- 在使⽤代码模拟实物时，你可能会发现⾃⼰给类添加了太多细节：属性和⽅法越来越多，⽂件越来越⻓。在这种情况下，可能需要将类的⼀部分提取出来，作为⼀个独⽴的类。将⼤型类拆分成多个协同⼯作的⼩类，这种⽅法称为组合

		- 例如，在不断给 ElectricCar 类添加细节时，我们可能会发现其中包含很多专门针对汽⻋电池的属性和⽅法。在这种情况下，可将这些属性和⽅法提取出来，放到⼀个名为 Battery 的类中，并将⼀个 Battery 实例作为 ElectricCar 类的属性：

			-  

			- 在 ElectricCar 类中，添加⼀个名为 self.battery 的属性（⻅❸）。这⾏代码让 Python 创建⼀个新的 Battery 实例，并将该实例赋给属性self.battery。

### 导入类

- 随着不断地给类添加功能，⽂件可能变得很⻓，即便妥善地使⽤了继承和组合亦如此。遵循 Python 的整体理念，应该让⽂件尽量整洁。Python 在这⽅⾯提供了帮助，允许你将类存储在模块中，然后在主程序中导⼊所需的模块。

- 导⼊单个类

	- 下⾯创建⼀个只包含 Car 类的模块：将 Car 类存储在⼀个名为 car.py 的模块中

		-  

			- ❶处是⼀个模块级⽂档字符串，对该模块的内容做了简要的描述。你应该为⾃⼰创建的每个模块编写⽂档字符串。

	- 下⾯来创建另⼀个⽂件——my_car.py，在其中导⼊ Car 类并创建其实例

		-  

			- import 语句（⻅❶）让 Python 打开模块car 并导⼊其中的 Car 类。这样，我们就可以使⽤ Car 类，就像它是在当前⽂件中定义的⼀样。

	- 导⼊类是⼀种⾼效的编程⽅式。如果这个程序包含整个 Class 类，它该有多⻓啊！通过将这个类移到⼀个模块中并导⼊该模块，依然可使⽤其所有功能，但主程序⽂件变得整洁易读了。这还让你能够将⼤部分逻辑存储在独⽴的⽂件中。在确定类能像你希望的那样⼯作后，就可以不管这些⽂件，专注于主程序的⾼级逻辑了。

- 在⼀个模块中存储多个类

	- 尽管同⼀个模块中的类之间应该存在某种相关性，但其实可以根据需要在⼀个模块中存储任意数量的类。Battery 类和 ElectricCar 类都可帮助模拟汽⻋，下⾯将它们都加⼊模块 car.py

		-  

			- 现在，可以新建⼀个名为 my_electric_car.py 的⽂件，导⼊ ElectricCar类，并创建⼀辆电动汽⻋了

- 从⼀个模块中导⼊多个类

	- 如果要在同⼀个程序中创建燃油汽⻋和电动汽⻋，就需要将 Car 类和 ElectricCar 类都导⼊

		- 当从⼀个模块中导⼊多个类时，⽤逗号分隔各个类（⻅❶）。

- 导⼊整个模块

	- 还可以先导⼊整个模块，再使⽤点号访问需要的类。这种导⼊⽅法很简单，代码也易读。由于创建类实例的代码都包含模块名，因此不会与当前⽂件使⽤的任何名称发⽣冲突。下⾯的代码导⼊整个 car 模块，并创建⼀辆燃油汽⻋和⼀辆电动汽⻋：

- 导⼊模块中的所有类

	- 要导⼊模块中的每个类，可使⽤下⾯的语法

		- 不推荐这种导⼊⽅式，原因有⼆。第⼀，最好只需要看⼀下⽂件开头的import 语句，就能清楚地知道程序使⽤了哪些类。但这种导⼊⽅式没有明确地指出使⽤了模块中的哪些类。第⼆，这种导⼊⽅式还可能引发名称⽅⾯的迷惑。如果不⼩⼼导⼊了⼀个与程序⽂件中的其他东⻄同名的类，将引发难以诊断的错误。

		- 当需要从⼀个模块中导⼊很多类时，还是最好在导⼊整个模块之后使module_name.classname 语法来访问这些类。

- 在⼀个模块中导⼊另⼀个模块

	- 有时候，需要将类分散到多个模块中，以免模块太⼤或者在同⼀个模块中存储不相关的类。在将类存储在多个模块中时，你可能会发现⼀个模块中的类依赖于另⼀个模块中的类（继承）。在这种情况下，可在前⼀个模块中导⼊必要的类。

	- 下⾯将 Car 类存储在⼀个模块中，并将 ElectricCar 和 Battery 类存储在另⼀个模块中。

		- ElectricCar 类需要访问其⽗类 Car，因此直接将 Car 类导⼊该模块。如果忘记了这⾏代码，Python 将在我们试图创建 ElectricCar 实例时报错。

		- 现在可分别从每个模块中导⼊类，以根据需要创建任意类型的汽⻋了

- 使⽤别名

	- 给类起别名：

	- 给模块指定别名：

- 找到合适的⼯作流程

	- ⼀开始应让代码结构尽量简单。⾸先尝试在⼀个⽂件中完成所有的⼯作，确定⼀切都能正确运⾏后，再将类移到独⽴的模块中。如果你喜欢模块和⽂件的交互⽅式，可在项⽬开始时就尝试将类存储到模块中。先找出让你能够编写出可⾏代码的⽅式，再尝试让代码更加整洁。

### Python 标准库

- Python 标准库是⼀组模块，在安装 Python 时已经包含在内。

- 例如：模块 random

	- 在这个模块中，⼀个有趣的函数是 randint()。它将两个整数作为参数，并随机返回⼀个位于这两个整数之间（含）的整数

	- 在模块 random 中，另⼀个很有⽤的函数是 choice()。它将⼀个列表或元组作为参数，并随机返回其中的⼀个元素：

### 类的编程⻛格

- 类名应采⽤驼峰命名法，即将类名中的每个单词的⾸字⺟都⼤写，并且不使⽤下划线。

- 实例名和模块名都采⽤全⼩写格式，并在单词之间加上下划线

- 对于每个类，都应在类定义后⾯紧跟⼀个⽂档字符串。这种⽂档字符串简要地描述类的功能，你应该遵循编写函数的⽂档字符串时采⽤的格式约定。

- 每个模块也都应包含⼀个⽂档字符串，对其中的类可⽤来做什么进⾏描述。

- 可以使⽤空⾏来组织代码，但不宜过多。在类中，可以使⽤⼀个空⾏来分隔⽅法；⽽在模块中，可以使⽤两个空⾏来分隔类。

- 当需要同时导⼊标准库中的模块和你编写的模块时，先编写导⼊标准库模块的 import 语句，再添加⼀个空⾏，然后编写导⼊你⾃⼰编写的模块的import 语句。在包含多条 import 语句的程序中，这种做法让⼈更容易明⽩程序使⽤的各个模块来⾃哪⾥。

## 第九章、文件和异常

### 读取⽂件

- 要使⽤⽂本⽂件中的信息，⾸先需要将信息读取到内存中。既可以⼀次性读取⽂件的全部内容，也可以逐⾏读取。

- 读取⽂件的全部内容

	- 下⾯的程序打开并读取这个⽂件，再将其内容显⽰到屏幕上

	- 要使⽤⽂件的内容，需要将其路径告知 Python。路径（path）指的是⽂件或⽂件夹在系统中的准确位置。Python 提供了 pathlib 模块，让你能够更轻松地在各种操作系统中处理⽂件和⽬录。提供特定功能的模块通常称为库（library）。这就是这个模块被命名为 pathlib 的原因所在。

		- 这⾥⾸先从 pathlib 模块导⼊ Path 类。Path 对象指向⼀个⽂件，可⽤来做很多事情。例如，让你在使⽤⽂件前核实它是否存在，读取⽂件的内容，以及将新数据写⼊⽂件。

		- 由于这个⽂件与当前编写的 .py ⽂件位于同⼀个⽬录中，因此 Path 只需要知道其⽂件名就能访问它。

	- 创建表⽰⽂件 pi_digits.txt 的 Path 对象后，使⽤ read_text() ⽅法来读取这个⽂件的全部内容（⻅❷）。read_text() 将该⽂件的全部内容作为⼀个字符串返回，⽽我们将这个字符串赋给了变量 contents

	-  

		- 相⽐于原始⽂件，该输出唯⼀不同的地⽅是末尾多了⼀个空⾏。为何会多出这个空⾏呢？因为 read_text() 在到达⽂件末尾时会返回⼀个空字符串，⽽这个空字符串会被显⽰为⼀个空⾏。要删除这个多出来的空⾏，可对字符串变量 contents 调⽤ rstrip()：

	- 注意：在读取⽂本⽂件时，Python 将其中的所有⽂本都解释为字符串。如果读取的是数，并且要将其作为数值使⽤，就必须使⽤ int()函数将其转换为整数，或者使⽤ float() 函数将其转换为浮点数。

- 相对⽂件路径和绝对⽂件路径

	- 当将类似于 pi_digits.txt 这样的简单⽂件名传递给 Path 时，Python 将在当前执⾏的⽂件（即 .py 程序⽂件）所在的⽬录中查找

	- 在编程中，指定路径的⽅式有两种。⾸先，相对⽂件路径让 Python 到相对于当前运⾏的程序所在⽬录的指定位置去查找。

		- 由于⽂件夹 text_files 位于⽂件夹 python_work 中，因此需要创建⼀个以 text_files 打头并以⽂件名结尾的路径，如下所⽰

	- 其次，可以将⽂件在计算机中的准确位置告诉 Python，这样就不⽤管当前运⾏的程序存储在什么地⽅了。这称为绝对⽂件路径

		- 绝对路径通常⽐相对路径⻓，因为它们以系统的根⽂件夹为起点

	- 注意：在显⽰⽂件路径时，Windows 系统使⽤反斜杠（\）⽽不是斜杠（/）。但是你在代码中应该始终使⽤斜杠，即便在 Windows 系统中也是如此。在与你或其他⽤户的系统交互时，pathlib 库会⾃动使⽤正确的路径表⽰⽅法。

- 访问⽂件中的各⾏

	- 你可以使⽤ splitlines() ⽅法将冗⻓的字符串转换为⼀系列⾏，再使⽤for 循环以每次⼀⾏的⽅式检查⽂件中的各⾏

		- 与前⾯⼀样，⾸先读取⽂件的全部内容（⻅❶）。如果要处理⽂件中的各⾏，就⽆须在读取⽂件时删除任何空⽩。splitlines() ⽅法返回⼀个列表，其中包含⽂件中所有的⾏，⽽我们将这个列表赋给了变量 lines

### 写入文件

- 写⼊⼀⾏

	- 定义⼀个⽂件的路径后，就可使⽤ write_text() 将数据写⼊该⽂件了

		- write_text() ⽅法接受单个实参，即要写⼊⽂件的字符串。

		- 注意：Python 只能将字符串写⼊⽂本⽂件。如果要将数值数据存储到⽂本⽂件中，必须先使⽤函数 str() 将其转换为字符串格式。

- 写⼊多⾏

	- write_text() ⽅法会在幕后完成⼏项⼯作。⾸先，如果 path 变量对应的路径指向的⽂件不存在，就创建它。其次，将字符串写⼊⽂件后，它会确保⽂件得以妥善地关闭。如果没有妥善地关闭⽂件，可能会导致数据丢失或受损。

		- 注意：在对 path 对象调⽤ write_text() ⽅法时，务必谨慎。如果指定的⽂件已存在， write_text() 将删除其内容，并将指定的内容写⼊其中。本章后⾯将介绍如何使⽤ pathlib 检查指定的⽂件是否存在。

### 异常

- Python 使⽤称为异常（exception）的特殊对象来管理程序执⾏期间发⽣的错误。

	- 每当发⽣让 Python 不知所措的错误时，它都会创建⼀个异常对象。如果你编写了处理该异常的代码，程序将继续运⾏；如果你未对异常进⾏处理，程序将停⽌，并显⽰⼀个 traceback，其中包含有关异常的报告。

	- 异常是使⽤ try-except 代码块处理的。try-except 代码块让 Python执⾏指定的操作，同时告诉 Python 在发⽣异常时应该怎么办。在使⽤try-except 代码块时，即便出现异常，程序也将继续运⾏：显⽰你编写的友好的错误消息，⽽不是令⽤户迷惑的 traceback。

- 处理 ZeroDivisionError 异常

	-  

		-  

			- 在上述 traceback 中，错误 ZeroDivisionError 是个异常对象（⻅❶）。Python 在⽆法按你的要求做时，就会创建这种对象。

- 使⽤ try-except 代码块

	- 当你认为可能发⽣错误时，可编写⼀个 try-except 代码块来处理可能引发的异常。你让 Python 尝试运⾏特定的代码，并告诉它如果这些代码引发了指定的异常，该怎么办

		- 这⾥将导致错误的代码⾏ print(5/0) 放在⼀个 try 代码块中。如果 try代码块中的代码运⾏起来没有问题，Python 将跳过 except 代码块；如果try 代码块中的代码导致错误，Python 将查找与之匹配的 except 代码块并运⾏其中的代码。

		- 在这个⽰例中，try 代码块中的代码引发了 ZeroDivisionError 异常，因此 Python 查找指出了该怎么办的 except 代码块，并运⾏其中的代码

		- 如果 try-except 代码块后⾯还有其他代码，程序将继续运⾏，因为Python 已经知道了如何处理错误。

- 使⽤异常避免崩溃

	- 如果在错误发⽣时，程序还有⼯作没有完成，妥善地处理错误就显得尤其重要。这种情况经常出现在要求⽤户提供输⼊的程序中。如果程序能够妥善地处理⽆效输⼊，就能提⽰⽤户提供有效输⼊，⽽不⾄于崩溃

		- 程序崩溃可不好，让⽤户看到 traceback 也不是个好主意。不懂技术的⽤户会感到糊涂，怀有恶意的⽤户还能通过 traceback 获悉你不想让他们知道的信息。例如，他们将知道你的程序⽂件的名称，还将看到部分不能正确运⾏的代码。有时候，训练有素的攻击者可根据这些信息判断出可对你的代码发起什么样的攻击。

- else 代码块

	-  

		- 这个⽰例还包含⼀个 else 代码块，只有 try代码块成功执⾏才需要继续执⾏的代码，都应放到 else 代码块中

		- except 代码块告诉 Python，在出现ZeroDivisionError 异常时该怎么办（⻅❷）。如果 try 代码块因零除错误⽽失败，就打印⼀条友好的消息，告诉⽤户如何避免这种错误。程序会继续运⾏，⽽⽤户根本看不到traceback

		- 只有可能引发异常的代码才需要放在 try 语句中。有时候，有⼀些仅在try 代码块成功执⾏时才需要运⾏的代码，这些代码应放在 else 代码块中。except 代码块告诉 Python，如果在尝试运⾏ try 代码块中的代码时引发了指定的异常该怎么办。

- 处理 FileNotFoundError 异常

	- 下⾯的程序尝试读取⽂件 alice.txt 的内容，但这个⽂件并没有被存储在 alice.py 所在的⽬录中

		- 请注意，这⾥使⽤ read_text() 的⽅式与前⾯稍有不同。如果系统的默认编码与要读取的⽂件的编码不⼀致，参数 encoding 必不可少。如果要读取的⽂件不是在你的系统中创建的，这种情况更容易发⽣

		-  

			- 这⾥的 traceback ⽐前⾯的那些都⻓，因此下⾯介绍如何看懂复杂的traceback。通常最好从 traceback 的末尾着⼿。从最后⼀⾏可知，引发了异常 FileNotFoundError（⻅❸）。这⼀点很重要，它让我们知道应该在要编写的 except 代码块中使⽤哪种异常。
		回头看看 traceback 开头附近（⻅❶），从这⾥可知，错误发⽣在⽂件alice.py 的第四⾏。接下来的⼀⾏列出了导致错误的代码⾏（⻅❷）。traceback 的其余部分列出了⼀些代码，它们来⾃打开和读取⽂件涉及的库。通常，不需要详细阅读和理解 traceback 中的这些内容。

			- 为了处理这个异常，应将 traceback 指出的存在问题的代码⾏放到 try 代码块中。这⾥，存在问题的是包含 read_text() 的代码⾏

- 分析⽂本

	- 下⾯来提取童话 Alice in Wonderland（《爱丽丝漫游奇境记》）的⽂本，并尝试计算它包含多少个单词。我们将使⽤ split() ⽅法，它默认以空⽩为分隔符将字符串分拆成多个部分

		- 对变量 contents（它现在是⼀个⻓⻓的字符串，包含童话 Alice inWonderland 的全部⽂本）调⽤ split() ⽅法，⽣成⼀个列表，其中包含这部童话中的所有单词（⻅❶）。这些代码都放在 else 代码块中，因为仅当 try 代码块成功执⾏时才会执⾏它们。

- 使⽤多个⽂件

	-  

		-  

			- 先将⽂件名存储为简单字符串，然后将每个字符串转换为 Path 对象（⻅❶），再调⽤count_words()。

			- 在这个⽰例中，使⽤ try-except 代码块有两个重要的优点：⼀是避免⽤户看到 traceback，⼆是让程序可以继续分析能够找到的其他⽂件。如果不捕获因找不到 siddhartha.txt ⽽引发的 FileNotFoundError 异常，⽤户将
看到完整的 traceback，⽽程序将在尝试分析 Siddhartha 后停⽌运⾏——根本不分析 Moby Dick 和 Little Women。

- 静默失败

	- 在上⼀个⽰例中，我们告诉⽤户有⼀个⽂件找不到。但并⾮每次捕获异常都需要告诉⽤户，你有时候希望程序在发⽣异常时保持静默，就像什么都没有发⽣⼀样继续运⾏。要让程序静默失败，可像通常那样编写 try 代码块，但在 except 代码块中明确地告诉 Python 什么都不要做Python 有⼀个 pass 语句，可在代码块中使⽤它来让 Python 什么都不做

### 存储数据

- 很多程序要求⽤户输⼊某种信息，不管专注点是什么，程序都会把⽤户提供的信息存储在列表和字典等数据结构中，当⽤户关闭程序时，⼏乎总是要保存他们提供的信息。⼀种简单的⽅式是使⽤模块 json 来存储数据。

	- 模块 json 让你能够将简单的 Python 数据结构转换为 JSON 格式的字符串，并在程序再次运⾏时从⽂件中加载数据。

- 使⽤ json.dumps() 和 json.loads()

	- json.dumps() 函数接受⼀个实参，即要转换为 JSON 格式的数据。这个函数返回⼀个字符串，这样你就可将其写⼊数据⽂件了：

		- 选择⼀个⽂件名，指定要将该数值列表存储到哪个⽂件中（⻅❶）。通常使⽤⽂件扩展名 .json 来指出⽂件存储的数据为 JSON 格式。接下来，使⽤ json.dumps() 函数⽣成⼀个字符串（⻅❷），它包含我们要存储的数据的 JSON 表⽰形式。⽣成这个字符串后，像本章前⾯⼀样，使⽤ write_text() ⽅法将其写⼊⽂件。

		- json文件的中数据的存储格式看起来与 Python 中⼀样

	- 下⾯再编写⼀个程序，使⽤ json.loads() 将这个列表读取到内存中

		- 在❶处，确保读取的是前⾯写⼊的⽂件。这个数据⽂件是使⽤特殊格式的⽂本⽂件，因此可使⽤ read_text() ⽅法来读取它（⻅❷）。然后将这个⽂件的内容传递给 json.loads()（⻅❸）。这个函数将⼀个 JSON 格式的字符串作为参数，并返回⼀个 Python 对象（这⾥是⼀个列表）

- 保存和读取⽤户⽣成的数据

	- 使⽤ json 保存⽤户⽣成的数据很有必要，因为如果不以某种⽅式进⾏存储，⽤户的信息就会在程序停⽌运⾏时丢失。下⾯来看⼀个这样的例⼦：提⽰⽤户在⾸次运⾏程序时输⼊⾃⼰的名字，并且在他再次运⾏程序时仍然记得他

		- 先来存储⽤户的名字：

		- 现在再编写⼀个程序，向名字已被存储的⽤户发出问候：

- 重构

	- 你经常会遇到这样的情况：虽然代码能够正确地运⾏，但还可以将其划分为⼀系列完成具体⼯作的函数来进⾏改进。这样的过程称为重构。重构让代码更清晰、更易于理解、更容易扩展。

		- 这个程序更加清晰，但 greet_user() 函数所做的不仅是问候⽤户，还在存储了⽤户名时获取它，在没有存储⽤户名时提⽰⽤户输⼊。下⾯重构 greet_user()，不让它执⾏这么多任务。⾸先将获取已存储⽤户名的代码移到另⼀个函数中：

			- 还需要将 greet_user() 中的另⼀个代码块提取出来，将在没有存储⽤户名时提⽰⽤户输⼊的代码放在⼀个独⽴的函数中

				- 在 remember_me.py 的这个最终版本中，每个函数都执⾏单⼀⽽清晰的任务。我们调⽤ greet_user()，它打印⼀条合适的消息：要么欢迎⽼⽤户回来，要么问候新⽤户。

## 第十章、测试代码

### 使⽤ pip 安装 pytest

- 虽然 Python 通过标准库提供了⼤量的功能，但 Python 开发⼈员还是需要频繁⽤到第三⽅包。

- 更新 pip

	- Python 提供了⼀款名为 pip 的⼯具，可⽤来安装第三⽅包。因为 pip 帮我们安装来⾃外部的包，所以更新频繁，以消除潜在的安全问题。有鉴于此，我们先来更新 pip。

		- 这个命令的第⼀部分（python -m pip）让 Python 运⾏ pip 模块；第⼆部分（install --upgrade）让 pip 更新⼀个已安装的包；⽽最后⼀部分（pip）指定要更新哪个第三⽅包。

		- 可使⽤下⾯的命令更新系统中安装的任何包：

- 安装 pytest

	- pip install pytest

### 测试函数

- 测试以下函数：

	- 为了核实get_formatted_name() 会像期望的那样⼯作，我们编写⼀个使⽤这个函数的程序。

- 单元测试和测试⽤例

	- 软件的测试⽅法多种多样。⼀种最简单的测试是单元测试（unit test），⽤于核实函数的某个⽅⾯没有问题。测试⽤例（test case）是⼀组单元测试，这些单元测试⼀道核实函数在各种情况下的⾏为都符合要求

		- 全覆盖（full coverage）测试⽤例包含⼀整套单元测试，涵盖了各种可能的函数使⽤⽅式。对于⼤型项⽬，要进⾏全覆盖测试可能很难。通常，最初只要针对代码的重要⾏为编写测试即可，等项⽬被⼴泛使⽤时再考虑全覆盖。

- 可通过的测试

	- 使⽤ pytest 进⾏测试，会让单元测试编写起来⾮常简单。我们将编写⼀个测试函数，它会调⽤要测试的函数，并做出有关返回值的断⾔。如果断⾔正确，表⽰测试通过；如果断⾔不正确，表⽰测试未通过。

		- 测试⽂件的名称很重要，必须以test_打头。当你让 pytest 运⾏测试时，它将查找以 test_打头的⽂件，并运⾏其中的所有测试。

		- 在这个测试⽂件中，⾸先导⼊要测试的 get_formatted_name() 函数，然后，定义⼀个测试函数 test_first_last_name()（⻅❶）。这个函数名⽐以前使⽤的都⻓，原因有⼆。第⼀，测试函数必须以 test_ 打头。在测试过程中，pytest 将找出并运⾏所有以 test_ 打头的函数。第⼆，测试函数的名称应该⽐典型的函数名更⻓，更具描述性。你⾃⼰不会调⽤测试函数，⽽是由 pytest 替你查找并运⾏它们。因此，测试函数的名称应⾜够⻓，让你在测试报告中看到它们时，能清楚地知道它们测试的是哪些⾏为。

		- 最后，做出⼀个断⾔（⻅❸）。断⾔（assertion）就是声称满⾜特定的条件：这⾥声称 formatted_name 的值为 'Janis Joplin'。

- 运⾏测试

	- 如果直接运⾏⽂件 test_name_function.py，将不会有任何输出，因为我们没有调⽤这个测试函数。相反，应该让 pytest 替我们运⾏这个测试⽂件。

	- 为此，打开⼀个终端窗⼝，并切换到这个测试⽂件所在的⽂件夹。在终端窗⼝中执⾏命令 pytest

		- ⽂件名后⾯的句点表明有⼀个测试通过了，⽽ 100% 指出运⾏了所有的测试。在可能有数百乃⾄数千个测试的⼤型项⽬中，句点和完成百分⽐有助于监控测试的运⾏进度

		- 上述输出表明，在给定包含名和姓的姓名时，get_formatted_name()函数总是能正确地处理。修改 get_formatted_name() 后，可再次运⾏这个测试。如果它通过了，就表明在给定 Janis Joplin 这样的姓名时，这个函数依然能够正确地处理。

- 未通过的测试

	- 我们来修改get_formatted_name()，使其能够处理中间名，但同时故意让这个函数⽆法正确地处理像 Janis Joplin 这样只有名和姓的姓名

		- 这次运⾏ pytest 时

		- ⾸先，输出中有⼀个字⺟ F（⻅❶），表明有⼀个测试未通过。然后是FAILURES 部分（⻅❷），这是关注的焦点，因为在运⾏测试时，通常应该关注未通过的测试。接下来，指出未通过的测试函数是test_first_last_name()（⻅❸）。右尖括号（⻅❹）指出了导致测试未能通过的代码⾏。下⼀⾏中的 E（⻅❺）指出了导致测试未通过的具体错误：缺少必不可少的位置实参 'last'，导致 TypeError。在末尾的简短⼩结中，再次列出了最重要的信息

- 在测试未通过时怎么办

	- 如果检查的条件没错，那么测试通过意味着函数的⾏为是对的，⽽测试未通过意味着你编写的新代码有错。因此，在测试未通过时，不要修改测试。因为如果你这样做，即便能让测试通过，像测试那样调⽤函数的代码也将突然崩溃。相反，应修复导致测试不能通过的代码

		- 就这⾥⽽⾔，最佳的选择是让中间名变为可选的。这样，不仅在使⽤类似于 Janis Joplin的姓名进⾏测试时可以通过，⽽且这个函数还能接受中间名。

		- 要将中间名设置为可选的，可在函数定义中将形参 middle 移到形参列表末尾，并将其默认值指定为⼀个空字符串。还需要添加⼀个 if 测试，以便根据是否提供了中间名相应地创建姓名

			- 为了确定这个函数依然能够正确地处理像 Janis Joplin 这样的姓名，再次运⾏测试，测试通过了。

- 添加新测试

	- 确定 get_formatted_name() ⼜能正确地处理简单的姓名后，我们再编写⼀个测试，⽤于测试包含中间名的姓名。为此，在⽂件test_name_function.py 中添加⼀个测试函数：

		- 我们将这个新函数命名为 test_first_last_middle_name()。记住，函数名必须以 test_ 打头，这样该函数才会在我们运⾏ pytest 时⾃动运⾏。这个函数名清楚地指出了它测试的是 get_formatted_name() 的哪个⾏为，如果该测试未通过，我们就能⻢上知道受影响的是哪种类型的姓名。

### 测试类

- 各种断⾔

	- 在编写测试时，可做出任何可表⽰为条件语句的断⾔。

- ⼀个要测试的类

	- 类的测试与函数的测试相似，所做的⼤部分⼯作是测试类中⽅法的⾏为。下⾯来编写⼀个要测试的类

		- 为了证明 AnonymousSurvey 类能够正确地⼯作，编写⼀个使⽤它的程序：

- 测试 AnonymousSurvey 类

	- 下⾯来编写⼀个测试，对 AnonymousSurvey 类的⾏为的⼀个⽅⾯进⾏验证。我们要验证的是，如果⽤户在⾯对调查问题时只提供⼀个答案，这个答案也能被妥善地存储

		- ⾸先，导⼊要测试的 AnonymousSurvey 类。第⼀个测试函数验证：调查问题的单个答案被存储后，它会包含在调查结果列表中。

		- 要测试类的⾏为，需要创建其实例。在❷处，使⽤问题"What language did you first learn to speak?" 创建⼀个名为language_survey 的实例，然后使⽤ store_response() ⽅法存储单个答案 English。接下来，通过断⾔ English 在列表language_survey.responses 中，核实这个答案被妥善地存储了

	- 如果在执⾏命令 pytest 时没有指定任何参数，pytest 将运⾏它在当前⽬录中找到的所有测试。为了专注于⼀个测试⽂件，可将该测试⽂件的名称作为参数传递给 pytest。

	- 下⾯来核实，当⽤户提供三个答案时，它们都将被妥善地存储。为此，再添加⼀个测试函数

		- 前述做法的效果很好，但这些测试有重复的地⽅。下⾯使⽤ pytest 的另⼀项功能来提⾼效率。

- 使⽤夹具

	- 在前⾯的 test_survey.py 中，我们在每个测试函数中都创建了⼀个AnonymousSurvey 实例。虽然这对于这个简单的⽰例来说不是问题，但在包含数⼗乃⾄数百个测试的项⽬中是个⼤问题。

	- 在测试中，夹具（fixture）可帮助我们搭建测试环境。这通常意味着创建供多个测试使⽤的资源。

		- 在 pytest 中，要创建夹具，可编写⼀个使⽤装饰器 @pytest.fixture 装饰的函数。装饰器（decorator）是放在函数定义前⾯的指令。在运⾏函数前，Python 将该指令应⽤于函数，以修改函数代码的⾏为。

	- 下⾯使⽤夹具创建⼀个 AnonymousSurvey 实例，让 test_survey.py 中的两个测试函数都可使⽤它

		- 现在需要导⼊ pytest，因为我们使⽤了其中定义的⼀个装饰器。。我们将装饰器 @pytest.fixture（⻅❶）应⽤于新函数language_survey()（⻅❷）。这个函数创建并返回⼀个AnonymousSurvey 对象。

		- 请注意，两个测试函数的定义都变了（⻅❸和❺）：都有⼀个名为language_survey 的形参。当测试函数的⼀个形参与应⽤了装饰器@pytest.fixture 的函数（夹具）同名时，将⾃动运⾏夹具，并将夹具返回的值传递给测试函数。

